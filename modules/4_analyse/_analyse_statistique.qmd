---
format:
  revealjs:
    theme: simple
    css: assets/style.css
    pagetitle: "Oncostat R - analyses"
    template-partials:
     - assets/title-slide.html
    title: "√âquipe ONCOSTAT <br> Modules de cours de R"
    subtitle: "Analyse descriptive & Analyse statistique"
    author: "Dan Chaltiel"
    description: "üéØ D√©crire et analyser vos donn√©es efficacement !"
    incremental: true
    controls: true
    keyboard: true
    code-line-numbers: true
    # embed-resources: true
    scrollable: true
    # toc: true
    slide-number: true
    smaller: true
    preview-links: auto
    footer: "Le code source de cette pr√©sentation est disponible [sur GitHub](https://github.com/Oncostat/rstat_training/){target='_blank'}."
execute:
  echo: true
  cache: true
  code-overflow: wrap
  warnings: false
  messages: false
keywords: ["r", "rstat", "training", "course", "module"]
mouse-wheel: true
knitr:
  opts_chunk: 
    collapse: true
    comment: "#>" 
    R.options:
      crosstable_compact: true
      width: 105
editor: 
  markdown: 
    wrap: 72
---

```{r}
#| include: false
library(tidyverse)
library(crosstable)
```

## Introduction

-   Pour les analyses statistiques, on utilise g√©n√©ralement des tests stats et des mod√®les de r√©gression

-   Dans ce cours, on verra :

    -  Les tests pour variables num√©riques et cat√©gorielles
    -  Les mod√®les lin√©aires, logistiques, et de Cox

## Tests : variables num√©riques

Pour les variables num√©riques, on utilise soit le t-test, soit le test de Wilcoxon.
    
. . . 

<br>

::: {.panel-tabset .no_fragment style="grid-template-columns: 23% 75%;"}

### Data

```{r}
db = mtcars2 %>% 
  select(mpg, am)
db
```

### 2-sample t-test

```{r}
t = t.test(mpg ~ am, data=db)
t

t$p.value
```

### 1-sample t-test

```{r}
t = t.test(mpg~1, mu=17, data=db)
t

t$p.value
```

### 2-sample Wilcoxon test

```{r}
w = wilcox.test(mpg ~ am, data=db)
w

w$p.value
```

### Attention!

L'interface traditionnelle est √† risque d'erreur!

```{r}
t.test(mtcars$mpg, mtcars$am)
```
Ici, `am` est binaire `0`/`1` et est trait√© comme une valeur num√©rique (moyenne 0.4).

:::   

## Tests : variables cat√©gorielles

Pour les variables cat√©gorielles, on utilise soit le test du Chi¬≤, soit le test exact de Fisher.
    
. . . 

<br>

::: {.panel-tabset .no_fragment style="grid-template-columns: 23% 75%;"}

### Data

```{r}
db = mtcars2 %>% 
  select(am, vs)
db
```

### 2-sample Chi-squared test

```{r}
tbl = table(db$am, db$vs)
tbl

cs = chisq.test(tbl)
cs

cs$p.value
```

### 2-sample Fisher exact test

```{r}
tbl = table(db$am, db$vs)
cs = fisher.test(tbl)
cs

cs$p.value
```


:::  


## Mod√©lisation

-   Un **mod√®le statistique** d√©crit la relation entre une ou plusieurs
    variables explicatives ($X_1, X_2, \dots, X_p$) et une variable
    r√©ponse ($Y$).

-   On veut pr√©dire $Y$ ou expliquer son lien avec $X$. $$
    Y = \beta_0 + \beta_1 X_1 + \beta_2 X_2 + \dots + \beta_p X_p + \varepsilon
    $$

-   Selon le type de r√©ponse, on utilisera un mod√®le de r√©gression
    diff√©rent, avec pour chacun des hypoth√®ses sp√©cifiques √† valider.

## Mod√©lisation en R

-   En R, la mod√©lisation repose sur des fonctions comme `lm()`, `glm()`
    et `coxph()`.

::: no_fragment
-   La syntaxe standard est la suivante :
    ```r
    formula = y ~ x1 + x2
    fit = regression_function(formula, data=my_data)
    ```
:::

-   L'objet `fit` contient toutes les informations de notre mod√®le.

-   On peut visualiser le r√©sultat avec la `summary(fit)`, ou mieux avec
    `broom::tidy(fit)` ou `gtsummary::tbl_regression()`.

## Donn√©es d'exemple

-   Pour commencer, on va utiliser les donn√©es simul√©es du dataset `ae` de
    `grstat_example()` contenant : le grade des adverse events
    `aegr`, le fait qu'il soit SAE `sae`, et la causalit√© `aerel`.
    
-   On va d'abord mod√©liser `aegr` (mod√®le lin√©aire), puis `sae` (mod√®le logistique).
-   Aper√ßu des donn√©es :
    ```{r}
    #| classes: "no_fragment"
    db = grstat::grstat_example(seed=100)
    db$ae %>% select(subjid, aegr, sae, aerel) %>% print(n=2)
    ```


::: {.callout-warning title="Mod√®le mixte" fragment-index=5}
Il y a plusieurs lignes par patient donc il aurait fallu rajouter un effet al√©atoire, 
mais √ßa d√©passe le cadre de ce cours.
:::

## Mod√®le lin√©aire (Y continu)

```{r}
#| classes: "no_fragment"
fit = lm(aegr ~ sae + aerel, data=db$ae)
```

. . . 

<br>

::: {.panel-tabset .no_fragment style="grid-template-columns: 16% 82%;"}
### fit

```{r}
fit
```

### summary()

```{r}
summary(fit)

confint(fit)
```

### tidy()

```{r}
broom::tidy(fit, conf.int=TRUE)
```

### gtsummary

```{r}
gtsummary::tbl_regression(fit, conf.int=TRUE)
```
:::

## Mod√®le lin√©aire : hypoth√®ses

:::::: {.panel-tabset .no_fragment style="grid-template-columns: 25% 73%;"}
### Lin√©arit√©

La relation entre $Y$ et les covariables $X$ doit √™tre lin√©aire.

Sur la courbe des r√©sidus en fonction des valeurs mod√©lis√©es, on
s'attend √† une courbe horizontale.

```{r}
plot(fit, which = 1)
```

::: notes
Une courbure indique que la relation entre les pr√©dicteurs et la r√©ponse
n'est pas lin√©aire ‚Üí un terme polynomial ou une transformation pourrait
√™tre n√©cessaire. Une forme en entonnoir sugg√®re une h√©t√©rosc√©dasticit√©
(voir which = 3).
:::

### Normalit√© des r√©sidus

Sur le QQplot, les points doivent suivre la droite diagonale.

```{r}
plot(fit, which = 2)
```

::: notes
Une d√©viation en queue de distribution (points qui s‚Äô√©cartent de la
diagonale aux extr√©mit√©s) indique des r√©sidus non normaux ‚Üí
potentiellement des valeurs aberrantes ou une distribution asym√©trique.
Une forte courbure peut sugg√©rer une distribution en cloche trop aplatie
ou trop pointue.
:::

### Homosc√©dasticit√©

La variance des r√©sidus doit √™tre constante, on s'attend √† une courbe
horizontale.

```{r}
plot(fit, which = 3)
lmtest::bptest(fit)
```

::: notes
Une forme en entonnoir (dispersion des points qui augmente avec les
valeurs pr√©dites) indique une h√©t√©rosc√©dasticit√© ‚Üí un mod√®le robuste ou
une transformation des variables pourrait √™tre n√©cessaire. Une variation
syst√©matique des points (ex. un motif en vague) sugg√®re que l'erreur
d√©pend des pr√©dicteurs.
:::
::::::

## Mod√®le logistique (Y binaire)

```{r}
#| classes: "no_fragment"
fit2 = glm(sae ~ aegr + aerel, data=db$ae, family=binomial(link="logit"))
#family: binomial (logit, probit...), gaussian (identity, log...), poisson, ...
```

. . . 

<br>

::: {.panel-tabset .no_fragment style="grid-template-columns: 16% 82%;"}
### fit

```{r}
fit2
```

### summary()

```{r}
summary(fit2)

confint(fit2)
```

### tidy()

```{r}
broom::tidy(fit2, conf.int=TRUE)
```

### gtsummary

```{r}
gtsummary::tbl_regression(fit2, conf.int=TRUE)
```
:::

## Mod√®le logistique : hypoth√®ses

::::: {.panel-tabset .fragment .no_fragment}
### Lin√©arit√©

La relation entre $Y$ et les covariables $X$ doit √™tre lin√©aire.

Sur la courbe des r√©sidus en fonction des valeurs mod√©lis√©es, on
s'attend √† une courbe horizontale.

```{r}
plot(fit2, which = 1)
```

::: notes
Une courbure indique que la relation entre les pr√©dicteurs et la r√©ponse
n'est pas lin√©aire ‚Üí un terme polynomial ou une transformation pourrait
√™tre n√©cessaire. Une forme en entonnoir sugg√®re une h√©t√©rosc√©dasticit√©
(voir which = 3).
:::

### Normalit√© des r√©sidus

La normalit√© des r√©sidus n'est **PAS** une hypoth√®se du mod√®le
logistique.

```{r}
plot(fit2, which = 2)
```

### Homosc√©dasticit√©

La variance des r√©sidus doit √™tre constante, on s'attend √† une courbe
horizontale.

```{r}
plot(fit2, which = 3)
```

::: notes
Une forme en entonnoir (dispersion des points qui augmente avec les
valeurs pr√©dites) indique une h√©t√©rosc√©dasticit√© ‚Üí un mod√®le robuste ou
une transformation des variables pourrait √™tre n√©cessaire. Une variation
syst√©matique des points (ex. un motif en vague) sugg√®re que l'erreur
d√©pend des pr√©dicteurs.
:::
:::::

## Analyses de survie

Pour l'exemple, on va simuler des donn√©es de survie selon une loi
exponentielle, avec 3 covariables : le bras de traitement `arm`, un
biomarqueur binaire `bm_bin`, et un biomarqueur continu `bm_cont`.

```{r data-function}
#| code-fold: true
#| code-summary: "Show the code for get_df()"
#| classes: "no_fragment"
#' Simulated dataset
#'
#' @param n number of observations
#' @param beta_trt,beta_bm_cont,beta_bm_cont the true coefficients
#' @param eos non-informative censoring (end of study)
#' @param seed RNG seed
surv_example = function(n=300, 
                  beta_trt=log(0.7), beta_bm_bin=log(1.5), beta_bm_cont=log(0.8),
                  eos=30, seed=42){
  set.seed(seed)
  # Generate covariates
  baseline = tibble(
    subjid = seq(n),
    arm = rep(c(0,1), each=n/2),   
    bm_bin = rbinom(n, 1, 0.4),
    bm_cont = rnorm(n),
  )

  rtn = baseline %>%
    mutate(
      # Generate exponential survival time
      log_predlin = beta_trt*arm + beta_bm_bin*bm_bin + beta_bm_cont*bm_cont,
      lambda0 = log(2)/10 / exp(beta_bm_bin*mean(bm_bin) + beta_bm_cont*mean(bm_cont)),
      lambda = lambda0 * exp(log_predlin),
      t_real = rexp(n, rate=lambda),

      # Administrative censorship
      t = pmin(t_real, eos),
      event = as.numeric(t_real<=eos),

      # labels
      arm =  factor(arm,  labels=c("Control", "Treatment")),
      bm_bin = factor(bm_bin, labels=c("Negative", "Positive")),
    )

  rtn %>%
    select(subjid, arm, t, event, bm_bin, bm_cont)
} 
```

```{r}
#| classes: "no_fragment"
df = surv_example()
df %>% print(n=2)
```

## Kaplan Meier & Log Rank

::: {.panel-tabset .fragment .no_fragment}
### survfit

```{r}
library(survival)
library(ggsurvfit)
km = survfit(Surv(t, event) ~ arm, data=df)
km
tidy_survfit(km, times=c(12,24)) %>% 
  select(strata, everything())
```

### Logrank

```{r}
survdiff(Surv(t, event) ~ arm, data=df)
survdiff(Surv(t, event) ~ arm + strata(bm_bin), data=df)
```

### KM plot (binaire)

https://www.danieldsjoberg.com/ggsurvfit/articles/gallery.html#kmunicate

```{r}
survfit2(Surv(t, event) ~ arm, data=df) %>% 
  ggsurvfit(, linetype_aes = TRUE) +
  add_confidence_interval() +
  add_risktable(
    risktable_stats = c("n.risk", "cum.censor", "cum.event")
  ) +
  theme_ggsurvfit_KMunicate() +
  scale_y_continuous(limits = c(0, 1)) +
  scale_x_continuous(expand = c(0.02, 0)) +
  theme(legend.position="inside", legend.position.inside = c(0.85, 0.85))
```

### KM plot (continu)

```{r}
model <- coxph(Surv(t, event) ~ bm_cont, data=df, x=TRUE)
contsurvplot::plot_surv_area(time="t", status="event", variable="bm_cont", data=df, model=model)
```
:::

## Mod√®le de Cox (Y survie)

```{r}
#| classes: "no_fragment"
fit_bare  = coxph(Surv(t, event) ~ arm, data=df)
fit_adj = coxph(Surv(t, event) ~ arm + bm_bin + bm_cont, data=df)
fit_strat = coxph(Surv(t, event) ~ arm + strata(bm_bin) + bm_cont, data=df)
```

::: {.panel-tabset .no_fragment}
### fit

```{r}
fit_adj
```

### summary()

```{r}
summary(fit_adj)

confint(fit_adj)
```

### tidy()

```{r}
broom::tidy(fit_adj, conf.int=TRUE)
```

### fit_strat

```{r}
broom::tidy(fit_strat, conf.int=TRUE)
```
:::

### gtsummary

```{r}
gtsummary::tbl_regression(fit_adj, conf.int=TRUE)
```

## Mod√®le de Cox: hypoth√®ses

::: {.panel-tabset .no_fragment}
### HHP table

```{r}
cox.zph(fit_adj)
```

### HHP plot

```{r}
cox.zph(fit_adj) %>% survminer::ggcoxzph()
```

### Linearity spline

```{r}
fit_spline = coxph(Surv(t, event) ~ pspline(bm_cont), data=df)
broom::tidy(fit_spline)
```

### Linearity plot

```{r}
fit_num = coxph(Surv(t, event) ~ bm_cont, data=df)
survminer::ggcoxfunctional(fit_num)
```
:::

## Test de mod√®les embo√Æt√©s

-   La plupart des mod√®les donnent un test de Wald pour chaque √©l√©ment.

-   Pour les variables cat√©gorielles, on peut √™tre int√©ress√© par un test
    du rapport de vraissemblance qui teste la variable globalement (pas
    les niveaux ind√©pendemment).

-   Il faut alors utiliser la fonction `anova()` sur deux mod√®les
    embo√Æt√©s.

```{r}
fit1 = coxph(Surv(t, event) ~ arm + bm_bin, data=df)
fit2 = coxph(Surv(t, event) ~ arm + bm_bin + bm_cont, data=df)
anova(fit1, fit2)
```

## Conclusion

-   Il y a beaucoup de fa√ßons de faire des mod√®les de r√©gression en R.

-   Il y a **beaucoup** de packages diff√©rents.

    -   Possibilit√©s infinies
    -   On peut parfois s'y perdre un peu

-   Attention √† la validit√© des packages, qui reste difficile √†
    d√©montrer

##  {#merci .center data-menu-title="Merci !" visibility="uncounted"}

::::: columns
::: {.column width="60%"}
![](media/bob.jpg){fig-align="center"}
:::

::: {.column width="40%"}
![](media/keep_calm.jpeg){fig-align="center"}
:::
:::::

# Backup {.appendix visibility="uncounted"}

## Mod√®les mixtes {visibility="uncounted"}

(lme4, nlme, mmrm), betareg

```{=html}
<script src="assets/custom.js"></script>
```
